\documentclass[10pt]{article}
\usepackage{template}
\usepackage{xspace}
\begin{document}
\title{template}
\newcommand{\hp}{\textsf{hp}\xspace}
\author{Fareed Sheriff}
\maketitle
\section{Introduction}
\par This is a description for a game made for the 2023 IAP Modern Zero-Knowledge and Weblab classes. It is a simple multiplayer game where each player consists of a circular base and square bullets. Every player starts with a circle of radius $r_i$ that shrinks as they fire bullets. The game ends when one person's \hp shrinks to $\leq 0$ (a win) or when both players' \hp are below the threshold required to fire a bullet (typically $1$ {\hp} --- a stalemate). Only bullets can harm players; players themselves cannot directly attack others. The game is played in a square field --- bullets that hit the border reflect off and players cannot go past the border.
\section{Mechanisms}
\par Players have access to circles (their base) and bullets. The player base radius is inversely proportional to the speed at which players move --- the smaller the base, the faster players move. The \hp of both players is initially set to $k>1$ to ensure that each person can fire off at least one bullet. The \hp of a player decreases by $1$ for each bullet fired and decreases by $k\geq 2$ for each opponent bullet they receive. The radius of the circle is $\sqrt{k_i}$ where $k$ is the \hp of player $i$ and as $k$ decreases, the radius decreases as well. Players can recover \hp by recovering their bullets, which they can do by either moving over their bullets or by pressing \tt{[CTRL]}, which pulls the bullets toward them. Players move their base with the arrow keys, aim bullets with the mouse, and fire bullets with \tt{[SPACE]}.
\section{Zero-Knowledge}
\par Each player also does not know the location of opponent bullets outside a predetermined radius of their base but does know the location of opponent bases. This radius is fixed for the duration of the game, so when a player's base shrinks they have greater area in which to see opponent items. This is implemented through a zero-knowledge proof that an opponent item is within some fixed radius of a player's base using a zk range proof. We also ensure that the locations of all player items are always up-to-date by hashing the coordinates into a Merkle tree and checking that the Merkle root is always the same. Also, for every new move that gets played, a zkp is generated for the move to verify that it doesn't violate board constraints and that it doesn't change direction or speed without influence from the base. Furthermore, we ensure that players do not teleport using a technique similar to the one used in the 'fog-of-war' implemented in Dark Forest.
%The initial radius of each person starts at where people have bases represented as circles and shoot parts of the base represented as squares. The game is played in a square grid and when one of your squares hits an opposing circle, the circle shrinks, indicating the player has lost health. Likewise, when a circle shoots a square, the radius of the circle decreases and the speed of the next square decreases as a result. However, the speed of the player increases as the radius decreases. Each square that collides with an opposing circle shrinks the radius by an amount equivalent to two squares. To recover squares, you can either move over the square with your circle or press a button that pulls all of your squares toward you with speed exponentially-proportional to your distance from them. If two opposing squares collide, they both disappear: this allows for a stalemate in special cases. Finally, we implement a 'fog-of-war' reminiscent of the Dark Forest fog-of-war, in which you can only see opponent pieces when they're within your range.
%\par We ensure that team members move fairly by verifying the radius of each circle as well as that the new position moved to by a player is within the speed range at that radius. We also ensure that the speed of squares decreases at a constant rate unless it is being pulled by its circle. Finally, we keep the list of locations up-to-date using a Merkle tree on hashed object coordinates and comparing the Merkle root often.
\end{document}
